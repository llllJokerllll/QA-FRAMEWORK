name: CD

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production

env:
  REGISTRY: ghcr.io
  BACKEND_IMAGE_NAME: ${{ github.repository }}/backend
  FRONTEND_IMAGE_NAME: ${{ github.repository }}/frontend

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: Cache Docker layers
      uses: actions/cache@v4
      with:
        path: /tmp/.buildx-cache
        key: ${{ runner.os }}-buildx-${{ github.sha }}
        restore-keys: |
          ${{ runner.os }}-buildx-
    
    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Extract metadata for backend
      id: meta-backend
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.BACKEND_IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}
          type=raw,value=staging,enable=${{ github.ref == 'refs/heads/main' }}
    
    - name: Extract metadata for frontend
      id: meta-frontend
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.FRONTEND_IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}
          type=raw,value=staging,enable=${{ github.ref == 'refs/heads/main' }}
    
    - name: Build and push backend image
      uses: docker/build-push-action@v5
      with:
        context: ./backend
        push: true
        tags: ${{ steps.meta-backend.outputs.tags }}
        labels: ${{ steps.meta-backend.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
    
    - name: Build and push frontend image
      uses: docker/build-push-action@v5
      with:
        context: ./frontend
        push: true
        tags: ${{ steps.meta-frontend.outputs.tags }}
        labels: ${{ steps.meta-frontend.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
    
    - name: Generate image digests
      run: |
        echo "Backend digest: ${{ steps.build-backend.outputs.digest }}"
        echo "Frontend digest: ${{ steps.build-frontend.outputs.digest }}"

  deploy-staging:
    needs: build-and-push
    runs-on: ubuntu-latest
    environment:
      name: staging
      url: https://staging.qa-framework.local
    if: github.ref == 'refs/heads/main' || github.event.inputs.environment == 'staging'
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
    
    - name: Create deployment files
      run: |
        mkdir -p deployment
        cat > deployment/docker-compose.staging.yml << 'EOF'
        version: '3.8'
        
        services:
          backend:
            image: ghcr.io/${{ github.repository }}/backend:staging
            ports:
              - "8000:8000"
            environment:
              - DATABASE_URL=${{ secrets.STAGING_DATABASE_URL }}
              - REDIS_HOST=redis
              - REDIS_PORT=6379
              - SECRET_KEY=${{ secrets.STAGING_SECRET_KEY }}
              - ENVIRONMENT=staging
            depends_on:
              - db
              - redis
            restart: unless-stopped
            healthcheck:
              test: ["CMD", "curl", "-f", "http://localhost:8000/api/v1/health"]
              interval: 30s
              timeout: 10s
              retries: 3
          
          frontend:
            image: ghcr.io/${{ github.repository }}/frontend:staging
            ports:
              - "3000:3000"
            environment:
              - VITE_API_URL=https://staging-api.qa-framework.local
            depends_on:
              - backend
            restart: unless-stopped
          
          db:
            image: postgres:15
            restart: always
            environment:
              POSTGRES_DB: qa_framework_staging
              POSTGRES_USER: ${{ secrets.STAGING_DB_USER }}
              POSTGRES_PASSWORD: ${{ secrets.STAGING_DB_PASSWORD }}
            volumes:
              - postgres_staging_data:/var/lib/postgresql/data
          
          redis:
            image: redis:7-alpine
            restart: always
            volumes:
              - redis_staging_data:/data
        
        volumes:
          postgres_staging_data:
          redis_staging_data:
        EOF
    
    - name: Deploy to staging server
      env:
        STAGING_HOST: ${{ secrets.STAGING_HOST }}
        STAGING_USER: ${{ secrets.STAGING_USER }}
        STAGING_KEY: ${{ secrets.STAGING_SSH_KEY }}
      run: |
        echo "Deploying to staging environment..."
        echo "$STAGING_KEY" > staging_key.pem
        chmod 600 staging_key.pem
        
        # Copy deployment files to server
        scp -i staging_key.pem -o StrictHostKeyChecking=no \
          deployment/docker-compose.staging.yml \
          $STAGING_USER@$STAGING_HOST:/opt/qa-framework/
        
        # Deploy on server
        ssh -i staging_key.pem -o StrictHostKeyChecking=no \
          $STAGING_USER@$STAGING_HOST << 'REMOTECOMMANDS'
          cd /opt/qa-framework
          docker-compose -f docker-compose.staging.yml pull
          docker-compose -f docker-compose.staging.yml up -d
          docker-compose -f docker-compose.staging.yml ps
        REMOTECOMMANDS
        
        rm -f staging_key.pem
    
    - name: Run smoke tests
      run: |
        echo "Running smoke tests on staging..."
        sleep 30
        
        # Test backend health
        curl -f https://staging-api.qa-framework.local/api/v1/health || {
          echo "Backend health check failed"
          exit 1
        }
        
        # Test frontend
        curl -f https://staging.qa-framework.local || {
          echo "Frontend health check failed"
          exit 1
        }
        
        echo "All smoke tests passed!"

  deploy-production:
    needs: build-and-push
    runs-on: ubuntu-latest
    environment:
      name: production
      url: https://qa-framework.local
    if: github.event.inputs.environment == 'production'
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
    
    - name: Create production deployment files
      run: |
        mkdir -p deployment
        cat > deployment/docker-compose.prod.yml << 'EOF'
        version: '3.8'
        
        services:
          backend:
            image: ghcr.io/${{ github.repository }}/backend:latest
            ports:
              - "8000:8000"
            environment:
              - DATABASE_URL=${{ secrets.PROD_DATABASE_URL }}
              - REDIS_HOST=redis
              - REDIS_PORT=6379
              - SECRET_KEY=${{ secrets.PROD_SECRET_KEY }}
              - ENVIRONMENT=production
            depends_on:
              - db
              - redis
            restart: unless-stopped
            healthcheck:
              test: ["CMD", "curl", "-f", "http://localhost:8000/api/v1/health"]
              interval: 30s
              timeout: 10s
              retries: 3
          
          frontend:
            image: ghcr.io/${{ github.repository }}/frontend:latest
            ports:
              - "3000:3000"
            environment:
              - VITE_API_URL=https://api.qa-framework.local
            depends_on:
              - backend
            restart: unless-stopped
          
          db:
            image: postgres:15
            restart: always
            environment:
              POSTGRES_DB: qa_framework_prod
              POSTGRES_USER: ${{ secrets.PROD_DB_USER }}
              POSTGRES_PASSWORD: ${{ secrets.PROD_DB_PASSWORD }}
            volumes:
              - postgres_prod_data:/var/lib/postgresql/data
          
          redis:
            image: redis:7-alpine
            restart: always
            volumes:
              - redis_prod_data:/data
        
        volumes:
          postgres_prod_data:
          redis_prod_data:
        EOF
    
    - name: Deploy to production server
      env:
        PROD_HOST: ${{ secrets.PROD_HOST }}
        PROD_USER: ${{ secrets.PROD_USER }}
        PROD_KEY: ${{ secrets.PROD_SSH_KEY }}
      run: |
        echo "Deploying to production environment..."
        echo "$PROD_KEY" > prod_key.pem
        chmod 600 prod_key.pem
        
        # Copy deployment files to server
        scp -i prod_key.pem -o StrictHostKeyChecking=no \
          deployment/docker-compose.prod.yml \
          $PROD_USER@$PROD_HOST:/opt/qa-framework/
        
        # Deploy on server
        ssh -i prod_key.pem -o StrictHostKeyChecking=no \
          $PROD_USER@$PROD_HOST << 'REMOTECOMMANDS'
          cd /opt/qa-framework
          docker-compose -f docker-compose.prod.yml pull
          docker-compose -f docker-compose.prod.yml up -d
          docker-compose -f docker-compose.prod.yml ps
        REMOTECOMMANDS
        
        rm -f prod_key.pem
    
    - name: Run production smoke tests
      run: |
        echo "Running smoke tests on production..."
        sleep 30
        
        # Test backend health
        curl -f https://api.qa-framework.local/api/v1/health || {
          echo "Backend health check failed"
          exit 1
        }
        
        # Test frontend
        curl -f https://qa-framework.local || {
          echo "Frontend health check failed"
          exit 1
        }
        
        echo "All production smoke tests passed!"

  notify-deployment:
    needs: [deploy-staging, deploy-production]
    if: always()
    runs-on: ubuntu-latest
    steps:
    - name: Notify on deployment success
      if: ${{ needs.deploy-staging.result == 'success' || needs.deploy-production.result == 'success' }}
      run: |
        echo "ðŸš€ Deployment completed successfully!"
    
    - name: Notify on deployment failure
      if: ${{ needs.deploy-staging.result == 'failure' || needs.deploy-production.result == 'failure' }}
      run: |
        echo "âŒ Deployment failed. Please review the logs."
        exit 1

  rollback-on-failure:
    needs: [deploy-staging, deploy-production]
    if: failure()
    runs-on: ubuntu-latest
    steps:
    - name: Rollback staging
      if: ${{ needs.deploy-staging.result == 'failure' }}
      env:
        STAGING_HOST: ${{ secrets.STAGING_HOST }}
        STAGING_USER: ${{ secrets.STAGING_USER }}
        STAGING_KEY: ${{ secrets.STAGING_SSH_KEY }}
      run: |
        echo "Rolling back staging deployment..."
        echo "$STAGING_KEY" > staging_key.pem
        chmod 600 staging_key.pem
        
        ssh -i staging_key.pem -o StrictHostKeyChecking=no \
          $STAGING_USER@$STAGING_HOST << 'REMOTECOMMANDS'
          cd /opt/qa-framework
          docker-compose -f docker-compose.staging.yml down
          docker-compose -f docker-compose.staging.yml up -d --force-recreate
        REMOTECOMMANDS
        
        rm -f staging_key.pem
